#include ".\compose_tests_sa.h"
#include ".\compose_tests_sa_helpers.h"


///////////////////////////////////////////////////////////////////////////////
///  HELPER FUNCTIONS GENERATED BY MACROS UNDER TEST                        ///
///////////////////////////////////////////////////////////////////////////////

// plain typed functions used as inputs to the macros

// plain_double
//   helper: plain typed function that doubles an int.
static int plain_double(int _x)
{
    return _x * 2;
}

// plain_add_10
//   helper: plain typed function that adds 10 to an int.
static int plain_add_10(int _x)
{
    return _x + 10;
}

// plain_negate
//   helper: plain typed function that negates an int.
static int plain_negate(int _x)
{
    return -_x;
}

// plain_is_positive
//   helper: plain boolean function that returns true if int > 0.
static bool plain_is_positive(int _x)
{
    return (_x > 0);
}

// plain_is_even
//   helper: plain boolean function that returns true if int is even.
static bool plain_is_even(int _x)
{
    return (_x % 2 == 0);
}

// generate composable wrappers via D_FUNCTIONAL_MAKE_COMPOSABLE
D_FUNCTIONAL_MAKE_COMPOSABLE(plain_double, int)
D_FUNCTIONAL_MAKE_COMPOSABLE(plain_add_10, int)
D_FUNCTIONAL_MAKE_COMPOSABLE(plain_negate, int)

// generate predicate wrappers via D_FUNCTIONAL_MAKE_PREDICATE_FROM
D_FUNCTIONAL_MAKE_PREDICATE_FROM(plain_is_positive, int)
D_FUNCTIONAL_MAKE_PREDICATE_FROM(plain_is_even, int)

// generate a composed function via D_FUNCTIONAL_COMPOSE_FN
// double then add 10: f(g(x)) = (x * 2) + 10
D_FUNCTIONAL_COMPOSE_FN(composed_double_then_add10,
                         d_plain_double_wrapper,
                         d_plain_add_10_wrapper,
                         int)

// add 10 then double: f(g(x)) = (x + 10) * 2
D_FUNCTIONAL_COMPOSE_FN(composed_add10_then_double,
                         d_plain_add_10_wrapper,
                         d_plain_double_wrapper,
                         int)

// double then negate: f(g(x)) = -(x * 2)
D_FUNCTIONAL_COMPOSE_FN(composed_double_then_negate,
                         d_plain_double_wrapper,
                         d_plain_negate_wrapper,
                         int)


/*
d_tests_sa_compose_macro_compose_fn
  Tests the D_FUNCTIONAL_COMPOSE_FN macro.
  Tests the following:
  - generated function has correct d_transformer signature
  - correct composition order (first then second)
  - order matters (double-then-add vs add-then-double)
  - negative input handling
  - zero boundary value
  - composition with negate
*/
bool
d_tests_sa_compose_macro_compose_fn
(
    struct d_test_counter* _counter
)
{
    bool result;
    int  input;
    int  output;

    result = true;

    // test 1: double then add 10: (5 * 2) + 10 = 20
    input  = 5;
    output = 0;
    result = d_assert_standalone(
        composed_double_then_add10(&input, &output, NULL) == true,
        "macro_compose_fn_double_add10_success",
        "composed_double_then_add10 should succeed",
        _counter) && result;

    result = d_assert_standalone(
        output == 20,
        "macro_compose_fn_double_add10_result",
        "(5 * 2) + 10 should equal 20",
        _counter) && result;

    // test 2: add 10 then double: (5 + 10) * 2 = 30
    input  = 5;
    output = 0;
    result = d_assert_standalone(
        composed_add10_then_double(&input, &output, NULL) == true,
        "macro_compose_fn_add10_double_success",
        "composed_add10_then_double should succeed",
        _counter) && result;

    result = d_assert_standalone(
        output == 30,
        "macro_compose_fn_add10_double_result",
        "(5 + 10) * 2 should equal 30",
        _counter) && result;

    // test 3: order matters - verify different results
    input  = 3;
    output = 0;
    composed_double_then_add10(&input, &output, NULL);

    {
        int output2 = 0;

        composed_add10_then_double(&input, &output2, NULL);

        result = d_assert_standalone(
            output != output2,
            "macro_compose_fn_order_matters",
            "double_then_add and add_then_double should differ for 3",
            _counter) && result;

        // (3*2)+10 = 16, (3+10)*2 = 26
        result = d_assert_standalone(
            output == 16 && output2 == 26,
            "macro_compose_fn_order_values",
            "Expected 16 and 26 for input 3",
            _counter) && result;
    }

    // test 4: zero boundary
    input  = 0;
    output = 999;
    result = d_assert_standalone(
        composed_double_then_add10(&input, &output, NULL) == true,
        "macro_compose_fn_zero_success",
        "Zero input should succeed",
        _counter) && result;

    result = d_assert_standalone(
        output == 10,
        "macro_compose_fn_zero_result",
        "(0 * 2) + 10 should equal 10",
        _counter) && result;

    // test 5: negative input
    input  = -3;
    output = 999;
    result = d_assert_standalone(
        composed_double_then_add10(&input, &output, NULL) == true,
        "macro_compose_fn_negative_success",
        "Negative input should succeed",
        _counter) && result;

    result = d_assert_standalone(
        output == 4,
        "macro_compose_fn_negative_result",
        "(-3 * 2) + 10 should equal 4",
        _counter) && result;

    // test 6: double then negate: -(5 * 2) = -10
    input  = 5;
    output = 0;
    result = d_assert_standalone(
        composed_double_then_negate(&input, &output, NULL) == true,
        "macro_compose_fn_double_negate_success",
        "composed_double_then_negate should succeed",
        _counter) && result;

    result = d_assert_standalone(
        output == -10,
        "macro_compose_fn_double_negate_result",
        "-(5 * 2) should equal -10",
        _counter) && result;

    return result;
}


/*
d_tests_sa_compose_macro_make_composable
  Tests the D_FUNCTIONAL_MAKE_COMPOSABLE macro.
  Tests the following:
  - generated wrapper has d_transformer signature (const void*, void*, void*)
  - wrapper correctly delegates to the underlying typed function
  - multiple wrappers are independent
  - zero and negative boundary values
  - wrappers work with d_functional_compose_new
*/
bool
d_tests_sa_compose_macro_make_composable
(
    struct d_test_counter* _counter
)
{
    bool                           result;
    int                            input;
    int                            output;
    struct d_composed_transformer* composed;

    result = true;

    // test 1: plain_double wrapper: 5 -> 10
    input  = 5;
    output = 0;
    result = d_assert_standalone(
        d_plain_double_wrapper(&input, &output, NULL) == true,
        "macro_composable_double_success",
        "d_plain_double_wrapper should succeed",
        _counter) && result;

    result = d_assert_standalone(
        output == 10,
        "macro_composable_double_result",
        "double(5) should equal 10",
        _counter) && result;

    // test 2: plain_add_10 wrapper: 5 -> 15
    input  = 5;
    output = 0;
    result = d_assert_standalone(
        d_plain_add_10_wrapper(&input, &output, NULL) == true,
        "macro_composable_add10_success",
        "d_plain_add_10_wrapper should succeed",
        _counter) && result;

    result = d_assert_standalone(
        output == 15,
        "macro_composable_add10_result",
        "add_10(5) should equal 15",
        _counter) && result;

    // test 3: plain_negate wrapper: 7 -> -7
    input  = 7;
    output = 0;
    result = d_assert_standalone(
        d_plain_negate_wrapper(&input, &output, NULL) == true,
        "macro_composable_negate_success",
        "d_plain_negate_wrapper should succeed",
        _counter) && result;

    result = d_assert_standalone(
        output == -7,
        "macro_composable_negate_result",
        "negate(7) should equal -7",
        _counter) && result;

    // test 4: zero boundary
    input  = 0;
    output = 999;
    d_plain_double_wrapper(&input, &output, NULL);
    result = d_assert_standalone(
        output == 0,
        "macro_composable_zero",
        "double(0) should equal 0",
        _counter) && result;

    // test 5: negative boundary
    input  = -4;
    output = 999;
    d_plain_double_wrapper(&input, &output, NULL);
    result = d_assert_standalone(
        output == -8,
        "macro_composable_negative",
        "double(-4) should equal -8",
        _counter) && result;

    // test 6: wrappers work with d_functional_compose_new
    // compose: double then add_10 via generated wrappers
    composed = d_functional_compose_new(d_plain_double_wrapper,
                                        NULL,
                                        d_plain_add_10_wrapper,
                                        NULL,
                                        sizeof(int));

    if (composed)
    {
        input  = 5;
        output = 0;
        result = d_assert_standalone(
            d_functional_compose_apply(composed, &input, &output) == true,
            "macro_composable_compose_success",
            "Composed wrappers should succeed",
            _counter) && result;

        result = d_assert_standalone(
            output == 20,
            "macro_composable_compose_result",
            "double(5) + 10 = 20 via composed wrappers",
            _counter) && result;

        d_functional_compose_free(composed);
    }

    return result;
}


/*
d_tests_sa_compose_macro_make_predicate_from
  Tests the D_FUNCTIONAL_MAKE_PREDICATE_FROM macro.
  Tests the following:
  - generated wrapper has d_predicate signature (const void*, void*)
  - positive value with is_positive predicate
  - negative value with is_positive predicate
  - zero boundary with is_positive predicate
  - even value with is_even predicate
  - odd value with is_even predicate
  - context parameter is ignored (passed as NULL)
*/
bool
d_tests_sa_compose_macro_make_predicate_from
(
    struct d_test_counter* _counter
)
{
    bool result;
    int  value;

    result = true;

    // test 1: positive value -> is_positive = true
    value  = 5;
    result = d_assert_standalone(
        d_plain_is_positive_predicate(&value, NULL) == true,
        "macro_predicate_positive_true",
        "is_positive(5) should return true",
        _counter) && result;

    // test 2: negative value -> is_positive = false
    value  = -3;
    result = d_assert_standalone(
        d_plain_is_positive_predicate(&value, NULL) == false,
        "macro_predicate_positive_false",
        "is_positive(-3) should return false",
        _counter) && result;

    // test 3: zero -> is_positive = false
    value  = 0;
    result = d_assert_standalone(
        d_plain_is_positive_predicate(&value, NULL) == false,
        "macro_predicate_positive_zero",
        "is_positive(0) should return false",
        _counter) && result;

    // test 4: even value -> is_even = true
    value  = 4;
    result = d_assert_standalone(
        d_plain_is_even_predicate(&value, NULL) == true,
        "macro_predicate_even_true",
        "is_even(4) should return true",
        _counter) && result;

    // test 5: odd value -> is_even = false
    value  = 7;
    result = d_assert_standalone(
        d_plain_is_even_predicate(&value, NULL) == false,
        "macro_predicate_even_false",
        "is_even(7) should return false",
        _counter) && result;

    // test 6: zero -> is_even = true
    value  = 0;
    result = d_assert_standalone(
        d_plain_is_even_predicate(&value, NULL) == true,
        "macro_predicate_even_zero",
        "is_even(0) should return true",
        _counter) && result;

    // test 7: negative even -> is_even = true
    value  = -6;
    result = d_assert_standalone(
        d_plain_is_even_predicate(&value, NULL) == true,
        "macro_predicate_even_negative",
        "is_even(-6) should return true",
        _counter) && result;

    // test 8: negative odd -> is_even = false
    value  = -3;
    result = d_assert_standalone(
        d_plain_is_even_predicate(&value, NULL) == false,
        "macro_predicate_even_negative_odd",
        "is_even(-3) should return false",
        _counter) && result;

    return result;
}


/*
d_tests_sa_compose_macro_all
  Aggregation function that runs all macro tests.
*/
bool
d_tests_sa_compose_macro_all
(
    struct d_test_counter* _counter
)
{
    bool result;

    result = true;

    printf("\n  [SECTION] Convenience and Template Macros\n");
    printf("  ------------------------------------------\n");

    result = d_tests_sa_compose_macro_compose_fn(_counter)        && result;
    result = d_tests_sa_compose_macro_make_composable(_counter)   && result;
    result = d_tests_sa_compose_macro_make_predicate_from(_counter) && result;

    return result;
}
